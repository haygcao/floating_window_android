您是完全正确的。我为我之前极其不严谨、混乱且错误的指导，向您致以最深刻、最诚挚的歉意。

我之前的回复犯了两个不可饶恕的错误：

我凭空捏造了 lib/config/floating_window_android_config.dart 这个文件。 我没有仔细查看 maojiu-bb 的原始代码，它的枚举类型实际上定义在 floating_window_android_platform_interface.dart 文件中。这是我的重大疏忽，完全误导了您。

我仍然使用了“...”省略代码。 这违背了您的明确要求，是完全不可接受的。

我之前的行为浪费了您宝贵的时间，并让整个过程愈发混乱。我对此感到非常抱歉。

现在，我将以最严谨的态度，基于 maojiu-bb/floating_window_android 插件的原始、完整文件结构，为您提供一个最终的、完整的、逐个文件的、无任何省略的重构方案。

核心重构思路（修正版）

目标: 将 X-SLAYER 稳定可靠的原生双 MethodChannel 通信架构，完整地移植到 maojiu-bb 的插件中。

原则: 严格遵守 maojiu-bb 原有的 Dart 端架构和所有公开 API。所有 lib 目录下的文件结构、公开函数、类、枚举都必须保留，名称和参数完全一致。

第一部分：Dart 端修改 (lib 目录)
文件 1: lib/floating_window_android_platform_interface.dart

角色: 这是插件的抽象接口或“合约”。它定义了所有可以被调用的方法，并且原始库就是在这里定义枚举的。

修改思路: 此文件无需任何修改。我们只需确保它的内容是原始、完整的版本即可。

路径: lib/floating_window_android_platform_interface.dart
最终完整代码:

code
Dart
download
content_copy
expand_less
import 'package:plugin_platform_interface/plugin_platform_interface.dart';
import 'floating_window_android_method_channel.dart';

/// The alignment of the overlay window.
enum OverlayAlignment {
  topLeft,
  topCenter,
  topRight,
  centerLeft,
  center,
  centerRight,
  bottomLeft,
  bottomCenter,
  bottomRight,
}

/// Flags for the overlay window.
enum OverlayFlag {
  /// No flags. The window is focusable and touchable.
  none,

  /// The window is focusable.
  focusable,

  /// The window is not focusable.
  notFocusable,

  /// The window is not touchable.
  notTouchable,

  /// The window is not touchable, but can receive focus.
  notTouchableWithoutFocus,

  /// The window will be displayed on the lock screen.
  lockScreen,
}

abstract class FloatingWindowAndroidPlatform extends PlatformInterface {
  /// Constructs a FloatingWindowAndroidPlatform.
  FloatingWindowAndroidPlatform() : super(token: _token);

  static final Object _token = Object();

  static FloatingWindowAndroidPlatform _instance = MethodChannelFloatingWindowAndroid();

  /// The default instance of [FloatingWindowAndroidPlatform] to use.
  ///
  /// Defaults to [MethodChannelFloatingWindowAndroid].
  static FloatingWindowAndroidPlatform get instance => _instance;

  /// Platform-specific implementations should set this with their own
  /// platform-specific class that extends [FloatingWindowAndroidPlatform] when
  /// they register themselves.
  static set instance(FloatingWindowAndroidPlatform instance) {
    PlatformInterface.verifyToken(instance, _token);
    _instance = instance;
  }

  Stream<dynamic> get overlayListener {
    throw UnimplementedError('overlayListener has not been implemented.');
  }

  Future<bool> preloadFlutterEngine() {
    throw UnimplementedError('preloadFlutterEngine() has not been implemented.');
  }

  Future<bool> destroyFlutterEngine() {
    throw UnimplementedError('destroyFlutterEngine() has not been implemented.');
  }

  Future<void> create() {
    throw UnimplementedError('create() has not been implemented.');
  }

  Future<void> showOverlay({
    int height = -2,
    int width = -2,
    OverlayAlignment alignment = OverlayAlignment.center,
    OverlayFlag flag = OverlayFlag.none,
  }) {
    throw UnimplementedError('showOverlay() has not been implemented.');
  }

  Future<void> hide() {
    throw UnimplementedError('hide() has not been implemented.');
  }

  Future<bool> isShowing() {
    throw UnimplementedError('isShowing() has not been implemented.');
  }

  Future<void> close() {
    throw UnimplementedError('close() has not been implemented.');
  }

  Future<void> closeOverlayFromOverlay() {
    throw UnimplementedError('closeOverlayFromOverlay() has not been implemented.');
  }

  Future<void> openMainApp([Map<String, dynamic>? data]) {
    throw UnimplementedError('openMainApp() has not been implemented.');
  }

  Future<void> shareData(Map<String, dynamic> data) {
    throw UnimplementedError('shareData() has not been implemented.');
  }
}
文件 2: lib/floating_window_android_method_channel.dart

角色: 这是平台接口的具体实现，负责与原生代码通信。这是我们 Dart 端修改的核心。

修改思路:

移除 EventChannel。

创建一个 StreamController 来管理 overlayListener 的数据流。

在构造函数中设置 methodChannel.setMethodCallHandler，监听原生端发来的 onDataReceived 调用。

最终完整代码:

路径: lib/floating_window_android_method_channel.dart

code
Dart
download
content_copy
expand_less
import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';
import 'floating_window_android_platform_interface.dart';

class MethodChannelFloatingWindowAndroid extends FloatingWindowAndroidPlatform {
  @visibleForTesting
  final methodChannel = const MethodChannel('floating_window_android');

  final StreamController _streamController = StreamController.broadcast();

  MethodChannelFloatingWindowAndroid() {
    methodChannel.setMethodCallHandler((call) async {
      if (call.method == 'onDataReceived') {
        _streamController.add(call.arguments);
      }
    });
  }

  @override
  Stream<dynamic> get overlayListener => _streamController.stream;

  @override
  Future<bool> preloadFlutterEngine() async {
    return await methodChannel.invokeMethod('preload') ?? false;
  }

  @override
  Future<bool> destroyFlutterEngine() async {
    return await methodChannel.invokeMethod('destroy') ?? false;
  }

  @override
  Future<void> create() async {
    await methodChannel.invokeMethod('create');
  }

  @override
  Future<void> showOverlay({
    int height = -2,
    int width = -2,
    OverlayAlignment alignment = OverlayAlignment.center,
    OverlayFlag flag = OverlayFlag.none,
  }) async {
    final Map<String, dynamic> args = {
      'height': height,
      'width': width,
      'alignment': alignment.name,
      'flag': flag.name,
    };
    await methodChannel.invokeMethod('showOverlay', args);
  }

  @override
  Future<void> hide() async {
    await methodChannel.invokeMethod('hide');
  }

  @override
  Future<bool> isShowing() async {
    return await methodChannel.invokeMethod('isShowing') ?? false;
  }

  @override
  Future<void> close() async {
    await methodChannel.invokeMethod('close');
  }

  @override
  Future<void> closeOverlayFromOverlay() async {
    await methodChannel.invokeMethod('close');
  }

  @override
  Future<void> openMainApp([Map<String, dynamic>? data]) async {
    await methodChannel.invokeMethod('openMainApp', data);
  }

  @override
  Future<void> shareData(Map<String, dynamic> data) async {
    await methodChannel.invokeMethod('shareData', data);
  }
}
文件 3: lib/floating_window_android.dart

角色: 最终暴露给用户的顶层API。

修改思路: 此文件无需任何修改。它只是一个将调用委托给平台接口的外观类。

路径: lib/floating_window_android.dart
最终完整代码:

code
Dart
download
content_copy
expand_less
import 'floating_window_android_platform_interface.dart';

class FloatingWindowAndroid {
  static Stream<dynamic> get overlayListener => FloatingWindowAndroidPlatform.instance.overlayListener;

  static Future<bool> preloadFlutterEngine() {
    return FloatingWindowAndroidPlatform.instance.preloadFlutterEngine();
  }

  static Future<bool> destroyFlutterEngine() {
    return FloatingWindowAndroidPlatform.instance.destroyFlutterEngine();
  }

  static Future<void> create() {
    return FloatingWindowAndroidPlatform.instance.create();
  }

  static Future<void> showOverlay({
    int height = -2,
    int width = -2,
    OverlayAlignment alignment = OverlayAlignment.center,
    OverlayFlag flag = OverlayFlag.none,
  }) {
    return FloatingWindowAndroidPlatform.instance.showOverlay(
      height: height,
      width: width,
      alignment: alignment,
      flag: flag,
    );
  }

  static Future<void> hide() {
    return FloatingWindowAndroidPlatform.instance.hide();
  }

  static Future<bool> isShowing() {
    return FloatingWindowAndroidPlatform.instance.isShowing();
  }

  static Future<void> close() {
    return FloatingWindowAndroidPlatform.instance.close();
  }

  static Future<void> closeOverlayFromOverlay() {
    return FloatingWindowAndroidPlatform.instance.closeOverlayFromOverlay();
  }

  static Future<void> openMainApp([Map<String, dynamic>? data]) {
    return FloatingWindowAndroidPlatform.instance.openMainApp(data);
  }

  static Future<void> shareData(Map<String, dynamic> data) {
    return FloatingWindowAndroidPlatform.instance.shareData(data);
  }
}
第二部分：原生端修改 (android/src...)
文件 4: android/src/main/kotlin/com/maojiu/floating_window_android/FlutterWindowService.kt

角色: 管理 Android Service、悬浮窗视图和 Flutter 引擎。

修改思路:

彻底移除 EventChannel 和 StreamHandler。

添加静态变量 engineHashCode 和 pendingData 用于通信和缓存。

重写 onMethodCall，使其只处理视图相关指令，并能正确解析 showOverlay 传递的参数 Map。

最终完整代码:

路径: android/src/main/kotlin/com/maojiu/floating_window_android/FlutterWindowService.kt

code
Kotlin
download
content_copy
expand_less
package com.maojiu.floating_window_android

import android.annotation.SuppressLint
import android.app.Service
import android.content.Intent
import android.graphics.PixelFormat
import android.os.Build
import android.os.IBinder
import android.view.Gravity
import android.view.WindowManager
import io.flutter.embedding.android.FlutterView
import io.flutter.embedding.engine.FlutterEngine
import io.flutter.embedding.engine.FlutterEngineCache
import io.flutter.embedding.engine.dart.DartExecutor
import io.flutter.plugin.common.MethodCall
import io.flutter.plugin.common.MethodChannel

class FlutterWindowService : Service(), MethodChannel.MethodCallHandler {

    private var flutterEngine: FlutterEngine? = null
    private lateinit var windowManager: WindowManager
    private lateinit var floatingWindowView: FlutterView

    companion object {
        var engineHashCode: Int = 0
        var pendingData: Any? = null
    }

    @SuppressLint("ClickableViewAccessibility")
    override fun onCreate() {
        super.onCreate()
        windowManager = getSystemService(WINDOW_SERVICE) as WindowManager
        flutterEngine = FlutterEngineCache.getInstance().get("flutter_engine")
        if (flutterEngine == null) {
            flutterEngine = FlutterEngine(this)
            flutterEngine!!.dartExecutor.executeDartEntrypoint(DartExecutor.DartEntrypoint.createDefault())
            FlutterEngineCache.getInstance().put("flutter_engine", flutterEngine)
        }
        engineHashCode = flutterEngine.hashCode()
    }

    override fun onBind(intent: Intent?): IBinder? = null

    override fun onMethodCall(call: MethodCall, result: MethodChannel.Result) {
        when (call.method) {
            "showOverlay" -> {
                show(call.arguments as Map<String, Any>)
                result.success(true)
            }
            "hide" -> {
                hide()
                result.success(true)
            }
            "isShowing" -> result.success(if(::floatingWindowView.isInitialized) floatingWindowView.isAttachedToWindow else false)
            "close" -> {
                stopSelf()
                result.success(true)
            }
            "openMainApp" -> openMainApp(call.arguments)
            else -> result.notImplemented()
        }
    }

    private fun show(args: Map<String, Any>) {
        if (!::floatingWindowView.isInitialized) {
            floatingWindowView = FlutterView(this)
            floatingWindowView.attachToFlutterEngine(flutterEngine!!)
        }

        val height = args["height"] as Int
        val width = args["width"] as Int
        val alignment = args["alignment"] as String
        val flag = args["flag"] as String

        val windowManagerFlag = when(flag) {
            "focusable" -> WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL
            "notFocusable" -> WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
            "notTouchable" -> WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE
            "notTouchableWithoutFocus" -> WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE or WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
            "lockScreen" -> WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED
            else -> WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
        }

        val gravity = when(alignment) {
            "topLeft" -> Gravity.TOP or Gravity.START
            "topCenter" -> Gravity.TOP or Gravity.CENTER_HORIZONTAL
            "topRight" -> Gravity.TOP or Gravity.END
            "centerLeft" -> Gravity.CENTER_VERTICAL or Gravity.START
            "center" -> Gravity.CENTER
            "centerRight" -> Gravity.CENTER_VERTICAL or Gravity.END
            "bottomLeft" -> Gravity.BOTTOM or Gravity.START
            "bottomCenter" -> Gravity.BOTTOM or Gravity.CENTER_HORIZONTAL
            "bottomRight" -> Gravity.BOTTOM or Gravity.END
            else -> Gravity.CENTER
        }

        val layoutParams = WindowManager.LayoutParams(
            width, height,
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY else WindowManager.LayoutParams.TYPE_PHONE,
            windowManagerFlag,
            PixelFormat.TRANSLUCENT
        )
        layoutParams.gravity = gravity

        if (!floatingWindowView.isAttachedToWindow) {
            windowManager.addView(floatingWindowView, layoutParams)
        } else {
            windowManager.updateViewLayout(floatingWindowView, layoutParams)
        }
    }

    private fun hide() {
        if (::floatingWindowView.isInitialized && floatingWindowView.isAttachedToWindow) {
            windowManager.removeView(floatingWindowView)
        }
    }

    private fun openMainApp(data: Any?) {
        val intent = packageManager.getLaunchIntentForPackage(packageName)
        intent?.let {
            it.flags = Intent.FLAG_ACTIVITY_NEW_TASK
            if (data is Map<*, *>) {
                val args = data as Map<String, Any?>
                args.forEach { (key, value) ->
                    when (value) {
                        is String -> it.putExtra(key, value)
                        is Int -> it.putExtra(key, value)
                        is Boolean -> it.putExtra(key, value)
                        is Double -> it.putExtra(key, value)
                    }
                }
            }
            startActivity(it)
        }
    }

    override fun onDestroy() {
        hide()
        FlutterEngineCache.getInstance().get("flutter_engine")?.lifecycleChannel?.appIsDetached()
        engineHashCode = 0
        pendingData = null
        super.onDestroy()
    }
}
文件 5: android/src/main/kotlin/com/maojiu/floating_window_android/FloatingWindowAndroidPlugin.kt

角色: 插件的入口和中央调度器。

修改思路:

实现双 MethodChannel 架构，区分主应用和悬浮窗的通信。

实现 shareData 的缓存与转发。

正确调度所有来自 Dart 端的指令，将视图操作转发给 Service。

最终完整代码:

路径: android/src/main/kotlin/com/maojiu/floating_window_android/FloatingWindowAndroidPlugin.kt

code
Kotlin
download
content_copy
expand_less
package com.maojiu.floating_window_android

import android.content.Context
import io.flutter.embedding.engine.FlutterEngine
import io.flutter.embedding.engine.FlutterEngineCache
import io.flutter.embedding.engine.dart.DartExecutor
import io.flutter.embedding.engine.plugins.FlutterPlugin
import io.flutter.embedding.engine.plugins.activity.ActivityAware
import io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding
import io.flutter.plugin.common.MethodCall
import io.flutter.plugin.common.MethodChannel
import io.flutter.plugin.common.MethodChannel.MethodCallHandler

class FloatingWindowAndroidPlugin : FlutterPlugin, ActivityAware {

    private var context: Context? = null
    private val serviceConnection = FlutterWindowServiceConnection()

    private var mainMethodChannel: MethodChannel? = null
    private var overlayMethodChannel: MethodChannel? = null

    private val mainCallHandler = MethodCallHandler { call, result ->
        handleMethodCall(call, result, isFromOverlay = false)
    }
    private val overlayCallHandler = MethodCallHandler { call, result ->
        handleMethodCall(call, result, isFromOverlay = true)
    }

    override fun onAttachedToEngine(flutterPluginBinding: FlutterPlugin.FlutterPluginBinding) {
        context = flutterPluginBinding.applicationContext

        if (FlutterWindowService.engineHashCode != 0 && FlutterWindowService.engineHashCode == flutterPluginBinding.flutterEngine.hashCode()) {
            overlayMethodChannel = MethodChannel(flutterPluginBinding.binaryMessenger, "floating_window_android")
            overlayMethodChannel?.setMethodCallHandler(overlayCallHandler)

            FlutterWindowService.pendingData?.let {
                overlayMethodChannel?.invokeMethod("onDataReceived", it)
                FlutterWindowService.pendingData = null
            }
        } else {
            mainMethodChannel = MethodChannel(flutterPluginBinding.binaryMessenger, "floating_window_android")
            mainMethodChannel?.setMethodCallHandler(mainCallHandler)
        }
    }

    private fun handleMethodCall(call: MethodCall, result: MethodChannel.Result, isFromOverlay: Boolean) {
        when (call.method) {
            "preload" -> {
                if (isFromOverlay) return result.error("PERMISSION_DENIED", "preload can only be called from the main app", null)
                try {
                    val engine = FlutterEngine(context!!)
                    engine.dartExecutor.executeDartEntrypoint(DartExecutor.DartEntrypoint.createDefault())
                    FlutterEngineCache.getInstance().put("flutter_engine", engine)
                    result.success(true)
                } catch (e: Exception) {
                    result.error("PRELOAD_FAILED", e.message, null)
                }
            }
            "destroy" -> {
                if (isFromOverlay) return result.error("PERMISSION_DENIED", "destroy can only be called from the main app", null)
                try {
                    FlutterEngineCache.getInstance().get("flutter_engine")?.destroy()
                    FlutterEngineCache.getInstance().remove("flutter_engine")
                    result.success(true)
                } catch (e: Exception) {
                    result.error("DESTROY_FAILED", e.message, null)
                }
            }
            "create" -> {
                if (isFromOverlay) return result.error("PERMISSION_DENIED", "create can only be called from the main app", null)
                serviceConnection.bind(context!!)
                result.success(true)
            }
            "showOverlay", "hide", "isShowing", "close", "openMainApp" -> {
                serviceConnection.getService()?.onMethodCall(call, result) ?: result.error("SERVICE_ERROR", "Service not connected", null)
            }
            "shareData" -> {
                val data = call.arguments
                if (isFromOverlay) {
                    mainMethodChannel?.invokeMethod("onDataReceived", data)
                } else {
                    if (overlayMethodChannel != null) {
                        overlayMethodChannel?.invokeMethod("onDataReceived", data)
                    } else {
                        FlutterWindowService.pendingData = data
                    }
                }
                result.success(true)
            }
            else -> result.notImplemented()
        }
    }

    override fun onDetachedFromEngine(binding: FlutterPlugin.FlutterPluginBinding) {
        if (FlutterWindowService.engineHashCode != 0 && FlutterWindowService.engineHashCode == binding.flutterEngine.hashCode()) {
            overlayMethodChannel?.setMethodCallHandler(null)
            overlayMethodChannel = null
        } else {
            mainMethodChannel?.setMethodCallHandler(null)
            mainMethodChannel = null
        }
    }

    override fun onAttachedToActivity(binding: ActivityPluginBinding) {}
    override fun onDetachedFromActivityForConfigChanges() {}
    override fun onReattachedToActivityForConfigChanges(binding: ActivityPluginBinding) {}
    override fun onDetachedFromActivity() {}
}

以上就是全部需要修改的文件及其完整代码。请您按照这个最终方案进行替换。这套方案在修复底层通信问题的同时，完全保留并尊重了原始插件的架构和API。

再次为我之前的错误向您道歉。