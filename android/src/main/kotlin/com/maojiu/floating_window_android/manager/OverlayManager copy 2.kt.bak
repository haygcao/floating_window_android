package com.maojiu.floating_window_android.manager

import android.annotation.SuppressLint
import android.content.Context
import android.content.Intent
import android.graphics.PixelFormat
import android.graphics.Point
import android.net.Uri
import android.os.Build
import android.provider.Settings
import android.view.Gravity
import android.view.MotionEvent
import android.view.View
import android.view.WindowManager
import android.widget.FrameLayout
import com.maojiu.floating_window_android.constants.Constants
import io.flutter.FlutterInjector
import io.flutter.embedding.android.FlutterTextureView
import io.flutter.embedding.android.FlutterView
import io.flutter.embedding.engine.FlutterEngine
import io.flutter.embedding.engine.FlutterEngineCache
import io.flutter.embedding.engine.dart.DartExecutor
import io.flutter.plugin.common.EventChannel.EventSink
import io.flutter.plugin.common.MethodChannel

class OverlayManager(
    private val context: Context
) {
    private val windowManager: WindowManager by lazy {
        context.getSystemService(Context.WINDOW_SERVICE) as WindowManager
    }

    private var overlayView: FrameLayout? = null
    private var flutterEngine: FlutterEngine? = null
    private var flutterView: FlutterView? = null
    private var windowParams: WindowManager.LayoutParams? = null

    private var enableDrag = false
    private var positionGravity = Constants.NONE
    private var startX = 0f
    private var startY = 0f
    private var initialX = 0
    private var initialY = 0
    private var currentX = 0
    private var currentY = 0

    companion object {
        private const val PRELOADED_ENGINE_KEY = "preloaded_overlay_engine"
        private var isEnginePreloaded = false

        // --- Start of the new, robust, static communication bridge ---
        @JvmStatic
        private var staticEventSink: EventSink? = null
        
        // [核心修复] 将缓存从 Any? 改为一个可变的 Map，用于累积数据。
        @JvmStatic
        private var cachedData: MutableMap<String, Any?> = mutableMapOf()

        @JvmStatic
        fun setEventSink(sink: EventSink?) {
            staticEventSink = sink
            // 当 Sink 准备好时，如果缓存中有数据，则发送整个累积的 Map。
            if (sink != null && cachedData.isNotEmpty()) {
                // 发送的是一个 Map 的副本，以防万一
                sink.success(HashMap(cachedData))
                // 发送后清空缓存
                cachedData.clear()
            }
        }

        @JvmStatic
        fun shareDataToOverlay(data: Any?) {
            // [核心修复] 不再是覆盖，而是合并。
            if (data is Map<*, *>) {
                // 确保传入的是 Map 类型的数据
                @Suppress("UNCHECKED_CAST")
                val newMap = data as? Map<String, Any?>
                if (newMap != null) {
                    if (staticEventSink == null) {
                        // Sink 未准备好，将新数据合并到缓存 Map 中。
                        cachedData.putAll(newMap)
                    } else {
                        // Sink 已准备好，直接发送新数据。
                        // 注意：这里我们假设 UI 逻辑 (StateNotifier) 也是合并逻辑。
                        // 如果 UI 逻辑已经是合并，那么这里可以直接发送部分更新。
                        staticEventSink?.success(newMap)
                    }
                }
            }
        }
        // --- End of the static communication bridge ---

        // ... preloadFlutterEngine, cleanupPreloadedEngine, isFlutterEnginePreloaded 保持不变 ...
        fun preloadFlutterEngine(context: Context, dartEntryPoint: String = "overlayMain") {
            if (isEnginePreloaded) { return }
            try {
                val engine = FlutterEngine(context)
                val dartEntrypoint = DartExecutor.DartEntrypoint(
                    FlutterInjector.instance().flutterLoader().findAppBundlePath(),
                    dartEntryPoint
                )
                engine.dartExecutor.executeDartEntrypoint(dartEntrypoint)
                FlutterEngineCache.getInstance().put(PRELOADED_ENGINE_KEY, engine)
                isEnginePreloaded = true
            } catch (e: Exception) {
                android.util.Log.e("OverlayManager", "Failed to preload Flutter engine", e)
            }
        }

        fun cleanupPreloadedEngine() {
            try {
                FlutterEngineCache.getInstance().get(PRELOADED_ENGINE_KEY)?.destroy()
                FlutterEngineCache.getInstance().remove(PRELOADED_ENGINE_KEY)
                isEnginePreloaded = false
            } catch (e: Exception) {
                android.util.Log.e("OverlayManager", "Failed to cleanup preloaded engine", e)
            }
        }

        fun isFlutterEnginePreloaded(): Boolean {
            return isEnginePreloaded && FlutterEngineCache.getInstance().get(PRELOADED_ENGINE_KEY) != null
        }
    }

    // ... 其他所有 OverlayManager 的实例方法 (isPermissionGranted, showOverlay, etc.) 都保持不变 ...
    fun isPermissionGranted(): Boolean {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) Settings.canDrawOverlays(context) else true
    }

    fun requestPermission(): Intent {
        return Intent(
            Settings.ACTION_MANAGE_OVERLAY_PERMISSION,
            Uri.parse("package:${context.packageName}")
        ).addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
    }

    fun showOverlay(
        height: Int = Constants.MATCH_PARENT,
        width: Int = Constants.MATCH_PARENT,
        alignment: String = Constants.CENTER,
        flag: String = Constants.DEFAULT_FLAG,
        enableDrag: Boolean = false,
        positionGravity: String = Constants.NONE,
        startPosition: Map<String, Any>? = null,
        dartEntryPoint: String = "overlayMain"
    ) {
        if (overlayView != null) {
            closeOverlay()
        }
        this.enableDrag = enableDrag
        this.positionGravity = positionGravity
        flutterEngine = if (isFlutterEnginePreloaded()) {
            FlutterEngineCache.getInstance().get(PRELOADED_ENGINE_KEY)
        } else {
            FlutterEngine(context).also {
                val dartEntrypoint = DartExecutor.DartEntrypoint(
                    FlutterInjector.instance().flutterLoader().findAppBundlePath(),
                    dartEntryPoint
                )
                it.dartExecutor.executeDartEntrypoint(dartEntrypoint)
            }
        }
        flutterEngine?.let { engine ->
            FlutterEngineCache.getInstance().put("overlay_engine", engine)
            val overlayControlChannel = MethodChannel(engine.dartExecutor.binaryMessenger, Constants.OVERLAY_CONTROL_CHANNEL)
            overlayControlChannel.setMethodCallHandler { call, result ->
                if (call.method == "close") {
                    closeOverlay()
                    result.success(true)
                } else {
                    result.notImplemented()
                }
            }
            flutterView = FlutterView(context, FlutterTextureView(context)).apply { attachToFlutterEngine(engine) }
            overlayView = FrameLayout(context).apply {
                addView(flutterView, FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT)
            }
            val params = setupWindowParams(height, width, alignment, flag)
            if (startPosition != null) {
                currentX = (startPosition[Constants.X] as? Number)?.toInt() ?: 0
                currentY = (startPosition[Constants.Y] as? Number)?.toInt() ?: 0
                params.x = currentX
                params.y = currentY
            }
            if (enableDrag) {
                setupDragListener(flutterView)
            }
            try {
                windowManager.addView(overlayView, params)
                windowParams = params
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    private fun setupWindowParams(height: Int, width: Int, alignment: String, flag: String): WindowManager.LayoutParams {
        return WindowManager.LayoutParams().apply {
            format = PixelFormat.TRANSLUCENT
            flags = when (flag) {
                Constants.CLICK_THROUGH -> WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE or WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
                Constants.FOCUS_POINTER -> WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL
                Constants.LOCK_SCREEN -> (WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL or WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH) or WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED or WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON or WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD
                else -> WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL or WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH
            }
            type = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY else WindowManager.LayoutParams.TYPE_PHONE
            this.width = if (width == Constants.MATCH_PARENT) WindowManager.LayoutParams.MATCH_PARENT else if (width == Constants.WRAP_CONTENT) WindowManager.LayoutParams.WRAP_CONTENT else width
            this.height = if (height == Constants.MATCH_PARENT) WindowManager.LayoutParams.MATCH_PARENT else if (height == Constants.WRAP_CONTENT) WindowManager.LayoutParams.WRAP_CONTENT else height
            gravity = when (alignment) {
                Constants.TOP -> Gravity.TOP or Gravity.CENTER_HORIZONTAL
                Constants.BOTTOM -> Gravity.BOTTOM or Gravity.CENTER_HORIZONTAL
                Constants.LEFT -> Gravity.START or Gravity.CENTER_VERTICAL
                Constants.RIGHT -> Gravity.END or Gravity.CENTER_VERTICAL
                Constants.TOP_LEFT -> Gravity.TOP or Gravity.START
                Constants.TOP_RIGHT -> Gravity.TOP or Gravity.END
                Constants.BOTTOM_LEFT -> Gravity.BOTTOM or Gravity.START
                Constants.BOTTOM_RIGHT -> Gravity.BOTTOM or Gravity.END
                else -> Gravity.CENTER
            }
        }
    }

    @SuppressLint("ClickableViewAccessibility")
    private fun setupDragListener(targetView: View?) {
        var isDragging = false
        targetView?.setOnTouchListener { _, event ->
            when (event.action) {
                MotionEvent.ACTION_DOWN -> {
                    startX = event.rawX
                    startY = event.rawY
                    initialX = windowParams?.x ?: 0
                    initialY = windowParams?.y ?: 0
                    isDragging = false
                    false
                }
                MotionEvent.ACTION_MOVE -> {
                    val dx = event.rawX - startX
                    val dy = event.rawY - startY
                    if (!isDragging && (kotlin.math.abs(dx) > 5f || kotlin.math.abs(dy) > 5f)) {
                        isDragging = true
                    }
                    if (isDragging) {
                        currentX = (initialX + dx).toInt()
                        currentY = (initialY + dy).toInt()
                        windowParams?.let { params ->
                            params.x = currentX
                            params.y = currentY
                            try {
                                overlayView?.let { ov -> windowManager.updateViewLayout(ov, params) }
                            } catch (e: Exception) { e.printStackTrace() }
                        }
                        return@setOnTouchListener true
                    }
                    false
                }
                MotionEvent.ACTION_UP -> {
                    val wasDragging = isDragging
                    isDragging = false
                    if (wasDragging) {
                        handlePositionGravity()
                        return@setOnTouchListener true
                    }
                    false
                }
                else -> false
            }
        }
    }

    private fun handlePositionGravity() {
        if (positionGravity == Constants.NONE) return
        val size = Point()
        windowManager.defaultDisplay.getSize(size)
        val screenWidth = size.x
        when (positionGravity) {
            Constants.RIGHT -> currentX = screenWidth - (windowParams?.width ?: 0)
            Constants.LEFT -> currentX = 0
            Constants.AUTO -> currentX = if (currentX > screenWidth / 2) screenWidth - (windowParams?.width ?: 0) else 0
        }
        windowParams?.x = currentX
        try {
            windowManager.updateViewLayout(overlayView, windowParams)
        } catch (e: Exception) { e.printStackTrace() }
    }

    fun closeOverlay() {
        // 清理缓存，以防万一
        cachedData.clear()
        
        flutterEngine?.dartExecutor?.binaryMessenger?.let {
            MethodChannel(it, Constants.OVERLAY_CONTROL_CHANNEL).setMethodCallHandler(null)
        }
        try {
            if (overlayView != null) {
                windowManager.removeView(overlayView)
                overlayView = null
            }
        } catch (e: Exception) { e.printStackTrace() }
        flutterView?.detachFromFlutterEngine()
        flutterView = null
        flutterEngine?.let { engine ->
            if (engine != FlutterEngineCache.getInstance().get(PRELOADED_ENGINE_KEY)) {
                engine.destroy()
            }
            FlutterEngineCache.getInstance().remove("overlay_engine")
        }
        flutterEngine = null
        windowParams = null
    }

    fun updateFlag(flag: String): Boolean {
        if (windowParams == null || overlayView == null) return false
        windowParams?.flags = when (flag) {
            Constants.CLICK_THROUGH -> WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE or WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
            Constants.FOCUS_POINTER -> WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL
            else -> WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL or WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH
        }
        return try {
            windowManager.updateViewLayout(overlayView, windowParams)
            true
        } catch (e: Exception) {
            e.printStackTrace()
            false
        }
    }

    fun resizeOverlay(width: Int, height: Int): Boolean {
        if (windowParams == null || overlayView == null) return false
        windowParams?.width = if (width == Constants.MATCH_PARENT) WindowManager.LayoutParams.MATCH_PARENT else if (width == Constants.WRAP_CONTENT) WindowManager.LayoutParams.WRAP_CONTENT else width
        windowParams?.height = if (height == Constants.MATCH_PARENT) WindowManager.LayoutParams.MATCH_PARENT else if (height == Constants.WRAP_CONTENT) WindowManager.LayoutParams.WRAP_CONTENT else height
        return try {
            windowManager.updateViewLayout(overlayView, windowParams)
            true
        } catch (e: Exception) {
            e.printStackTrace()
            false
        }
    }

    fun moveOverlay(x: Int, y: Int): Boolean {
        if (windowParams == null || overlayView == null) return false
        windowParams?.x = x
        windowParams?.y = y
        currentX = x
        currentY = y
        return try {
            windowManager.updateViewLayout(overlayView, windowParams)
            true
        } catch (e: Exception) {
            e.printStackTrace()
            false
        }
    }

    fun getOverlayPosition(): Map<String, Int> {
        return mapOf(Constants.X to (windowParams?.x ?: 0), Constants.Y to (windowParams?.y ?: 0))
    }

    fun isShowing(): Boolean {
        return overlayView != null && overlayView?.isAttachedToWindow == true
    }
}