// 文件: com/maojiu/floating_window_android/manager/OverlayManager.kt
// 版本: 最小化修复版 (只解决 showOverlay 意外销毁引擎的问题)

package com.maojiu.floating_window_android.manager

import android.annotation.SuppressLint
import android.content.Context
import android.content.Intent
import android.graphics.PixelFormat
import android.graphics.Point
import android.net.Uri
import android.os.Build
import android.provider.Settings
import android.util.Log
import android.view.Gravity
import android.view.MotionEvent
import android.view.View
import android.view.WindowManager
import android.widget.FrameLayout
import com.maojiu.floating_window_android.constants.Constants
import io.flutter.FlutterInjector
import io.flutter.embedding.android.FlutterTextureView
import io.flutter.embedding.android.FlutterView
import io.flutter.embedding.engine.FlutterEngine
import io.flutter.embedding.engine.FlutterEngineCache
import io.flutter.embedding.engine.dart.DartExecutor
import io.flutter.plugin.common.EventChannel.EventSink
import io.flutter.plugin.common.MethodChannel

class OverlayManager(
    private val context: Context
) {
    private val windowManager: WindowManager by lazy {
        context.getSystemService(Context.WINDOW_SERVICE) as WindowManager
    }

    private var overlayView: FrameLayout? = null
    private var flutterEngine: FlutterEngine? = null
    private var flutterView: FlutterView? = null
    private var windowParams: WindowManager.LayoutParams? = null

    private var enableDrag = false
    private var positionGravity = Constants.NONE
    private var startX = 0f
    private var startY = 0f
    private var initialX = 0
    private var initialY = 0
    private var currentX = 0
    private var currentY = 0

    companion object {
        private const val TAG = "OverlayManager"
        private const val PRELOADED_ENGINE_KEY = "preloaded_overlay_engine"
        private var isEnginePreloaded = false

        @JvmStatic
        private var staticEventSink: EventSink? = null
        
        @JvmStatic
        private var cachedData: MutableMap<String, Any?> = mutableMapOf()

        @JvmStatic
        fun setEventSink(sink: EventSink?) {
            staticEventSink = sink
            if (sink != null && cachedData.isNotEmpty()) {
                sink.success(HashMap(cachedData))
                cachedData.clear()
            }
        }

        @JvmStatic
        fun shareDataToOverlay(data: Any?) {
            if (data is Map<*, *>) {
                @Suppress("UNCHECKED_CAST")
                val newMap = data as? Map<String, Any?>
                if (newMap != null) {
                    if (staticEventSink == null) {
                        cachedData.putAll(newMap)
                    } else {
                        staticEventSink?.success(newMap)
                    }
                }
            }
        }
        
        fun preloadFlutterEngine(context: Context, dartEntryPoint: String = "overlayMain") {
            if (isEnginePreloaded) { return }
            try {
                val engine = FlutterEngine(context)
                val dartEntrypoint = DartExecutor.DartEntrypoint(
                    FlutterInjector.instance().flutterLoader().findAppBundlePath(),
                    dartEntryPoint
                )
                engine.dartExecutor.executeDartEntrypoint(dartEntrypoint)
                FlutterEngineCache.getInstance().put(PRELOADED_ENGINE_KEY, engine)
                isEnginePreloaded = true
            } catch (e: Exception) {
                Log.e(TAG, "Failed to preload Flutter engine", e)
            }
        }

        fun cleanupPreloadedEngine() {
            try {
                FlutterEngineCache.getInstance().get(PRELOADED_ENGINE_KEY)?.destroy()
                FlutterEngineCache.getInstance().remove(PRELOADED_ENGINE_KEY)
                isEnginePreloaded = false
            } catch (e: Exception) {
                Log.e(TAG, "Failed to cleanup preloaded engine", e)
            }
        }

        fun isFlutterEnginePreloaded(): Boolean {
            return isEnginePreloaded && FlutterEngineCache.getInstance().get(PRELOADED_ENGINE_KEY) != null
        }
    }

    fun showOverlay(
        height: Int = Constants.MATCH_PARENT,
        width: Int = Constants.MATCH_PARENT,
        alignment: String = Constants.CENTER,
        flag: String = Constants.DEFAULT_FLAG,
        enableDrag: Boolean = false,
        positionGravity: String = Constants.NONE,
        startPosition: Map<String, Any>? = null,
        dartEntryPoint: String = "overlayMain"
    ) {
        // [*** 核心修复 ***]
        // 原始代码是: if (overlayView != null) { closeOverlay() }
        // closeOverlay() 会销毁引擎，导致通信中断。
        // 正确的做法是，如果已有一个引擎在运行，就不要再创建新的，直接复用即可。
        if (flutterEngine != null && overlayView != null && overlayView?.isAttachedToWindow == true) {
            Log.d(TAG, "Overlay is already showing. Aborting new show request to preserve engine and communication channel.")
            return // 直接返回，不执行任何操作，保护现有窗口和引擎。
        }
        // [*** 修复结束 ***]
        
        // 如果代码执行到这里，说明是第一次创建窗口，或者窗口已被正确关闭。
        // 后续的创建逻辑保持和插件原始代码一致。
        this.enableDrag = enableDrag
        this.positionGravity = positionGravity
        flutterEngine = if (isFlutterEnginePreloaded()) {
            FlutterEngineCache.getInstance().get(PRELOADED_ENGINE_KEY)
        } else {
            FlutterEngine(context).also {
                val dartEntrypoint = DartExecutor.DartEntrypoint(
                    FlutterInjector.instance().flutterLoader().findAppBundlePath(),
                    dartEntryPoint
                )
                it.dartExecutor.executeDartEntrypoint(dartEntrypoint)
            }
        }
        flutterEngine?.let { engine ->
            FlutterEngineCache.getInstance().put("overlay_engine", engine)
            val overlayControlChannel = MethodChannel(engine.dartExecutor.binaryMessenger, Constants.OVERLAY_CONTROL_CHANNEL)
            overlayControlChannel.setMethodCallHandler { call, result ->
                if (call.method == "close") {
                    closeOverlay()
                    result.success(true)
                } else {
                    result.notImplemented()
                }
            }
            flutterView = FlutterView(context, FlutterTextureView(context)).apply { attachToFlutterEngine(engine) }
            overlayView = FrameLayout(context).apply {
                addView(flutterView, FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT)
            }
            val params = setupWindowParams(height, width, alignment, flag)
            if (startPosition != null) {
                currentX = (startPosition[Constants.X] as? Number)?.toInt() ?: 0
                currentY = (startPosition[Constants.Y] as? Number)?.toInt() ?: 0
                params.x = currentX
                params.y = currentY
            }
            if (enableDrag) {
                setupDragListener(flutterView)
            }
            try {
                windowManager.addView(overlayView, params)
                windowParams = params
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }
    
    //
    // 以下所有方法均保持原始版本，未做任何修改
    //
    
    fun isPermissionGranted(): Boolean {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) Settings.canDrawOverlays(context) else true
    }

    fun requestPermission(): Intent {
        return Intent(
            Settings.ACTION_MANAGE_OVERLAY_PERMISSION,
            Uri.parse("package:${context.packageName}")
        ).addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
    }

    private fun setupWindowParams(height: Int, width: Int, alignment: String, flag: String): WindowManager.LayoutParams {
        return WindowManager.LayoutParams().apply {
            format = PixelFormat.TRANSLUCENT
            flags = when (flag) {
                Constants.CLICK_THROUGH -> WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE or WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
                Constants.FOCUS_POINTER -> WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL
                Constants.LOCK_SCREEN -> (WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL or WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH) or WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED or WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON or WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD
                else -> WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL or WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH
            }
            type = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY else WindowManager.LayoutParams.TYPE_PHONE
            this.width = if (width == Constants.MATCH_PARENT) WindowManager.LayoutParams.MATCH_PARENT else if (width == Constants.WRAP_CONTENT) WindowManager.LayoutParams.WRAP_CONTENT else width
            this.height = if (height == Constants.MATCH_PARENT) WindowManager.LayoutParams.MATCH_PARENT else if (height == Constants.WRAP_CONTENT) WindowManager.LayoutParams.WRAP_CONTENT else height
            gravity = when (alignment) {
                Constants.TOP -> Gravity.TOP or Gravity.CENTER_HORIZONTAL
                Constants.BOTTOM -> Gravity.BOTTOM or Gravity.CENTER_HORIZONTAL
                Constants.LEFT -> Gravity.START or Gravity.CENTER_VERTICAL
                Constants.RIGHT -> Gravity.END or Gravity.CENTER_VERTICAL
                Constants.TOP_LEFT -> Gravity.TOP or Gravity.START
                Constants.TOP_RIGHT -> Gravity.TOP or Gravity.END
                Constants.BOTTOM_LEFT -> Gravity.BOTTOM or Gravity.START
                Constants.BOTTOM_RIGHT -> Gravity.BOTTOM or Gravity.END
                else -> Gravity.CENTER
            }
        }
    }

    @SuppressLint("ClickableViewAccessibility")
    private fun setupDragListener(targetView: View?) {
        var isDragging = false
        targetView?.setOnTouchListener { _, event ->
            when (event.action) {
                MotionEvent.ACTION_DOWN -> {
                    startX = event.rawX
                    startY = event.rawY
                    initialX = windowParams?.x ?: 0
                    initialY = windowParams?.y ?: 0
                    isDragging = false
                    false
                }
                MotionEvent.ACTION_MOVE -> {
                    val dx = event.rawX - startX
                    val dy = event.rawY - startY
                    if (!isDragging && (kotlin.math.abs(dx) > 5f || kotlin.math.abs(dy) > 5f)) {
                        isDragging = true
                    }
                    if (isDragging) {
                        currentX = (initialX + dx).toInt()
                        currentY = (initialY + dy).toInt()
                        windowParams?.let { params ->
                            params.x = currentX
                            params.y = currentY
                            try {
                                overlayView?.let { ov -> windowManager.updateViewLayout(ov, params) }
                            } catch (e: Exception) { e.printStackTrace() }
                        }
                        return@setOnTouchListener true
                    }
                    false
                }
                MotionEvent.ACTION_UP -> {
                    val wasDragging = isDragging
                    isDragging = false
                    if (wasDragging) {
                        handlePositionGravity()
                        return@setOnTouchListener true
                    }
                    false
                }
                else -> false
            }
        }
    }

    private fun handlePositionGravity() {
        if (positionGravity == Constants.NONE) return
        val size = Point()
        windowManager.defaultDisplay.getSize(size)
        val screenWidth = size.x
        when (positionGravity) {
            Constants.RIGHT -> currentX = screenWidth - (windowParams?.width ?: 0)
            Constants.LEFT -> currentX = 0
            Constants.AUTO -> currentX = if (currentX > screenWidth / 2) screenWidth - (windowParams?.width ?: 0) else 0
        }
        windowParams?.x = currentX
        try {
            windowManager.updateViewLayout(overlayView, windowParams)
        } catch (e: Exception) { e.printStackTrace() }
    }

    fun closeOverlay() {
        cachedData.clear()
        
        flutterEngine?.dartExecutor?.binaryMessenger?.let {
            MethodChannel(it, Constants.OVERLAY_CONTROL_CHANNEL).setMethodCallHandler(null)
        }
        try {
            if (overlayView != null) {
                windowManager.removeView(overlayView)
                overlayView = null
            }
        } catch (e: Exception) { e.printStackTrace() }
        flutterView?.detachFromFlutterEngine()
        flutterView = null
        flutterEngine?.let { engine ->
            if (engine != FlutterEngineCache.getInstance().get(PRELOADED_ENGINE_KEY)) {
                engine.destroy()
            }
            FlutterEngineCache.getInstance().remove("overlay_engine")
        }
        flutterEngine = null
        windowParams = null
    }

    fun updateFlag(flag: String): Boolean {
        if (windowParams == null || overlayView == null) return false
        windowParams?.flags = when (flag) {
            Constants.CLICK_THROUGH -> WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE or WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
            Constants.FOCUS_POINTER -> WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL
            else -> WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL or WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH
        }
        return try {
            windowManager.updateViewLayout(overlayView, windowParams)
            true
        } catch (e: Exception) {
            e.printStackTrace()
            false
        }
    }

    fun resizeOverlay(width: Int, height: Int): Boolean {
        if (windowParams == null || overlayView == null) return false
        windowParams?.width = if (width == Constants.MATCH_PARENT) WindowManager.LayoutParams.MATCH_PARENT else if (width == Constants.WRAP_CONTENT) WindowManager.LayoutParams.WRAP_CONTENT else width
        windowParams?.height = if (height == Constants.MATCH_PARENT) WindowManager.LayoutParams.MATCH_PARENT else if (height == Constants.WRAP_CONTENT) WindowManager.LayoutParams.WRAP_CONTENT else height
        return try {
            windowManager.updateViewLayout(overlayView, windowParams)
            true
        } catch (e: Exception) {
            e.printStackTrace()
            false
        }
    }

    fun moveOverlay(x: Int, y: Int): Boolean {
        if (windowParams == null || overlayView == null) return false
        windowParams?.x = x
        windowParams?.y = y
        currentX = x
        currentY = y
        return try {
            windowManager.updateViewLayout(overlayView, windowParams)
            true
        } catch (e: Exception) {
            e.printStackTrace()
            false
        }
    }

    fun getOverlayPosition(): Map<String, Int> {
        return mapOf(Constants.X to (windowParams?.x ?: 0), Constants.Y to (windowParams?.y ?: 0))
    }

    fun isShowing(): Boolean {
        return overlayView != null && overlayView?.isAttachedToWindow == true
    }
}